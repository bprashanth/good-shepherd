<!-- ImagePanel.vue

@TODO:
  - This entire component needs a thorough refactor.
  - Decouple clicking logic from the DOM created by the json-viewer library.
  - Combine the image-switcher here and the editor-switcher in App.vue.
-->

<template>
    <!-- TODO:
      - Reinstate this click handler.
      - Add a check for the imageUrl to be a valid image.
      - If not, display a placeholder image.
      - Replace the placeholder text in the popup.
      - Debug failing fonts in the modal.
    -->
    <!-- <div v-if="imageUrl" class="image-container" @click="openPopup"> -->
    <div v-if="imageUrl" class="image-container" @click="openPopup">
        <img :src="imageUrl" alt="Selected Image">
    </div>

    <!-- Popup modal -->
    <div v-if="showPopup" class="popup-overlay" @click.self="closePopup">
        <div class="popup-card">
            <div class="popup-image-container" @click.stop="addNote">

              <!-- Image navigation buttons
                TODO: These buttons are the same as the ones in App.vue.
                  We should combine them into a single component.
              -->
              <div class="editor-switcher">
                <button @click.stop="showPrevious">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M15 6L9 12L15 18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
                <button @click.stop="showNext">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M9 18L15 12L9 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  </svg>
                </button>
              </div>

              <img :src="imageUrl" alt="Full Image" class="popup-image"/>
              <!-- Render notes -->
              <div v-for="(note, index) in notes" :key="index" class="note" :style="{ left: `${note.x}%`, top: `${note.y}%` }">
                {{ note.text }}
              </div>
            </div>
            <div class="popup-description">

              <!-- Banner of popup description -->
              <div class="popup-description-topbar">

                  <!-- Username and time -->
                  <div class="popup-description-username">

                      <!-- TODO(prashanth@): rethink whether using matchingRecord directly here is a good idea. -->
                      <span>{{ matchingRecord.site_id }}</span>
                      <span style="margin-left: 1em;">{{ formatDate(matchingRecord.date) || '6w ago' }}</span>
                  </div>

                  <!-- Popup close button: x -->
                  <button class="popup-close" @click="closePopup">&times;</button>
              </div>
              <div v-if="previewUrl" class="preview-container">
                <!-- Preview image with tile overlay -->
                <img
                :src="previewUrl"
                alt="preview map"
                class="preview-image"
                ref="previewImageRef"
                @load="() => {
                  if (isMapWithTiles.value) {
                    const tiles = getValueByPath(
                      matchingRecord.value,
                      tilesPath.value
                    );
                    updateTileOverlay(tiles);
                  }
                }"
                />
                <div class="tile-overlay" :style="tileOverlayStyle"></div>
              </div>
              <!-- TODO(prashanth@): just use matchingRecordIndex? -->
              <div v-if="matchingRecord && getDisplayableRecordData().length > 0" class="ai-section">
                  <div class="ai-results-content">
                    <div v-for="item in getDisplayableRecordData()" :key="item.key">
                      <div><strong>{{ item.key }}:</strong> {{ item.value }}</div>
                    </div>
                  </div>
                  <div class="ai-results-footer">
                      <strong>Results generated by AI</strong>
                  </div>
              </div>
            </div>
        </div>
    </div>
</template>

<script setup>
import { defineProps, ref, watchEffect, defineEmits, nextTick, computed } from 'vue';

const props = defineProps({
    field: Object,
    template: Object,
    queryResult: {
        type: Array,
        default: () => [],
    },
});

const effectiveQueryResult = computed(() => {
  return props.template?.queryResults || props.queryResult || [];
});

const emit = defineEmits(['note-update']);

const showPopup = ref(false);
// Record the path to the clicked field, for use in next/previous buttons.
const matchingFieldPath = ref('');
// Record the index of the matching record, for use in next/previous buttons.
const matchingRecordIndex = ref(-1);
// Record the matching record, for use in the popup.
// TODO(prashanth@): re-evaluate whether this is necessary. Why not just use
// the matchingRecordIndex?
const matchingRecord = ref({});
// Record the imageUrl to display in the popup.
const imageUrl = ref('');
// Record the notes to display in the popup.
const notes = ref([]);
// Local copy of queryResult to store notes.
// Set in watchEffect, to queryResult.
const localQueryResult = ref([]);

// Map/Tile navigation variables. Eg:
// {preview_url: "https://example.com/tile_1.png",
// tiles: [
//   {tile_url: "https://example.com/tile_1.png"},
//   {tile_url: "https://example.com/tile_2.png"},
//   {tile_url: "https://example.com/tile_3.png"},
// ]}
// currentTileIndex: 1
// tilesPath: "tiles"
// tileUrlField: "tile_url"
// previewUrl: "https://example.com/tile_1.png"
const isMapWithTiles = ref(false);
// Record the current tile index within the tiles array.
const currentTileIndex = ref(0);
// Record the path to the tiles array, eg tiles
const tilesPath = ref('');
// Record the field containing the tile url, eg tile_url (within each element
// of eg tiles)
const tileUrlField = ref('tile_url');

// Record the previewUrl to display in the popup modals rhs panel.
const previewUrl = ref('');

// Tiling over preview map styling variables.
const previewImageRef = ref(null);
const tileOverlayStyle = ref({});

/**
 * Add a note to the popup.
 *
 * This function uses relative offset coordinates to position the note.
 * Therefore it's important that any element it's used on should be positioned
 * absolutely. Moreover, justify-content: center; should NOT be used on the
 * parent element, because it messes with the coordinates of the notes. Ideally
 * the element should be width: 100% and height: 100% with object-fit: fill.
 *
 * @params
 *  - event: The event that triggered the note addition.
 */
function addNote(event) {
  // Ignore clicks outside the image.
  const imageElement = event.currentTarget.querySelector('img');
  if (!imageElement) return;

  const x = ((event.offsetX / imageElement.offsetWidth) * 100);
  const y = ((event.offsetY / imageElement.offsetHeight) * 100);

  const text = prompt('Enter note text:');
  if (text) {
    notes.value.push({ x, y, text});
  }
  console.log("ImagePanel: added notes: ", notes.value);
}

function saveNotes(index) {
  const record = localQueryResult.value[index];
  record.notes = [...notes.value];
  console.log("ImagePanel: saved notes: ", record.notes, "for index: ", index, "query result length: ", localQueryResult.value.length);

  emit('note-update', {
    notes: record.notes,
    fieldKey: matchingFieldPath.value,
    fieldValue: imageUrl.value
  })
}

function loadNotes(index) {
  const record = localQueryResult.value[index];
    if (!record) {
    console.warn("ImagePanel: No record found at index:", index);
    notes.value = [];
    return;
  }
  notes.value = record.notes || [];
  console.log("ImagePanel: loaded notes: ", notes.value, "for index: ", index, "query result length: ", localQueryResult.value.length);
}

/**
 * Detects if the current object is a map with tiles.
 *
 * The logic is as follows:
 *  - Check if the object has a key that includes "map" or "preview".
 *  - If it does, check if any key has "tiles" in it.
 *  - If it does, check if the value is an array of objects with any key
 *     containing "url" in it.
 *  - If all these conditions are met, return the object with the following
 *     properties:
 *     - isMap: true
 *     - tilesPath: the path to the tiles array
 *     - tileUrlField: the field containing the tile url
 *  - Otherwise, return an object with isMap set to false.
 *
 * @param {Object} obj - The object to check
 * @returns {Object} Object containing isMap, tilesPath, and tileUrlField
 */
function detectMapWithTiles(obj) {
  if (!obj || typeof obj !== 'object') {
    return { isMap: false, tilesPath: '', tileUrlField: '' };
  }

  // Check if object has map-related keys
  const hasMapKey = Object.keys(obj).some(key =>
    key.toLowerCase().includes('map') || key.toLowerCase().includes('preview')
  );

  if (!hasMapKey) {
    console.log("ImagePanel: tiles: no map-related keys found for object: ", obj);
    return { isMap: false, tilesPath: '', tileUrlField: '' };
  }

  // Look for tiles in the object
  for (const [key, value] of Object.entries(obj)) {
    if (key.toLowerCase().includes('tiles') && Array.isArray(value)) {
      console.log("ImagePanel: tiles: found tiles array: ", key, value);
      // Check if the array contains objects with tile_url
      if (value.length > 0 && typeof value[0] === 'object') {
        const firstTile = value[0];
        const tileUrlKey = Object.keys(firstTile).find(k =>
          k.toLowerCase().includes('url')
        );

        if (tileUrlKey) {
          console.log("ImagePanel: SUCCESS tiles: found tile url key: ", tileUrlKey);
          return {
            isMap: true,
            tilesPath: key,
            tileUrlField: tileUrlKey
          };
        }
      }
    }
  }
  console.log("ImagePanel: no tiles found for object: ", obj);

  return { isMap: false, tilesPath: '', tileUrlField: '' };
}

/**
 * Gets the tile URL at the specified index from the current object.
 *
 * Retrieves the tiles sub-object from the current object, and then the tile
 * url from the tile sub-object using the tileIndex field.
 *
 * @param {number} tileIndex - The index of the tile to get
 * @returns {string|null} The tile URL or null if not found
 */
function getTileUrl(tileIndex) {
  if (!isMapWithTiles.value || matchingRecordIndex.value === -1) {
    return null;
  }

  const currentRecord = effectiveQueryResult.value[matchingRecordIndex.value];
  const tiles = getValueByPath(currentRecord, tilesPath.value);
  console.log("ImagePanel: tiles: looking for tile url at index: ", tileIndex, "tile path: ", tilesPath.value, " got tiles: ", tiles);

  if (!Array.isArray(tiles) || tileIndex < 0 || tileIndex >= tiles.length) {
    console.log("ImagePanel: tiles: no tiles found at index: ", tileIndex, "tile path: ", tilesPath.value, " got tiles: ", tiles);
    return null;
  }

  const tile = tiles[tileIndex];
  return tile[tileUrlField.value];
}

/**
 * Gets the value of a field by its path.
 *
 * This function first assumes the path is a literal key. If that fails, it
 * tries dot notation. Eg:
 *
 * path: foo.bar.baz
 * first checks for {foo.bar.baz: 0}
 * and then for {foo: {bar: {baz: 0}}}
 *
 * @params
 *  - obj: The object to get the value from.
 *  - path: The path to the value.
 *
 * @returns {Object} The value of the field.
 */
const getValueByPath = (obj, path) => {
    // First try literal key
    if (obj && obj[path] !== undefined) {
        return obj[path];
    }

    // Then try dot notation
    return path.split('.').reduce((acc, key) => (acc && acc[key] !== undefined ? acc[key] : null), obj);
};

/**
 * Updates the imageUrl based on the clicked field or tile navigation.
 *
 * The main entrypoint for updateImageUrl is the watchEffect that runs when
 * the user clicks on an image. The props change (the field changes) and hence
 * we need to update the imageUrl.
 *
 * One of the important jobs of this function is to set the "previewUrl". When
 * we click on an object with an image, if that object has a previewUrl, we
 * save it to display in the popup modals rhs panel. We do this because the
 * main panel of the popup could be used not to display the preview but eg: the
 * tiles of a map.
 *
 *
 * @param {Object} obj - The object to get the value from.
 * @param {string} path - The path to the value.
 */
const updateImageUrl = (obj, path) => {
  if (!obj || !path) return;

  console.log("ImagePanel: updateImageUrl, path: ", path, "object: ", obj);

  // Chsiteseck if this is a map with tiles
  const mapInfo = detectMapWithTiles(obj);
  isMapWithTiles.value = mapInfo.isMap;
  tilesPath.value = mapInfo.tilesPath;
  tileUrlField.value = mapInfo.tileUrlField;

  // Set the previewUrl.
  if (isMapWithTiles.value) {
    previewUrl.value = getValueByPath(obj, 'preview_url') ||
      getValueByPath(obj, 'previewUrl') ||
      getValueByPath(obj, 'preview') ||
      getValueByPath(obj, 'map_url') ||
      getValueByPath(obj, 'mapUrl') ||
      getValueByPath(obj, 'map') ||
      '';

    // Prefetch tile 0 to reduce jitter when opening popup
    // TODO(prashanth@): gh/issue/23
    const tileUrl = getTileUrl(0);
    if (tileUrl && isImage(tileUrl)) {
      console.log("ImagePanel: prefetching tile 0: ", tileUrl);
      // Create a hidden image element to prefetch
      const prefetchImg = new Image();
      prefetchImg.src = tileUrl;
    }
  } else {
    previewUrl.value = '';
  }

  if (isMapWithTiles.value && showPopup.value) {
    // In popup mode for maps with tiles, show the first tile by default
    const tileUrl = getTileUrl(0);
    if (tileUrl && isImage(tileUrl)) {
      console.log("ImagePanel: showing tile URL: ", tileUrl);
      imageUrl.value = tileUrl;
      currentTileIndex.value = 0;
      return;
    }
  }

  // Fall back to normal behavior
  const content = getValueByPath(obj, path);
  if (typeof content != 'string' || !content) {
    console.warn(
      'ImagePanel: content is not a string, skipping img update: ', content);
    return;
  }
  if (isImage(content)) {
      console.log("imageUrl computed: ", content);
      imageUrl.value = content;
  } else {
    console.warn(
      "ImagePanel: content is not a valid image url: ", content);
  }
}

function isImage(textContent) {
  if (!textContent) return false;
  const cleanContent = textContent.trim().replace(/['"]+/g, '');

  const urlWithoutParams = cleanContent.split('?')[0];

  return (cleanContent.includes('/data/') ||
    /\.(jpg|jpeg|png|webp)$/i.test(urlWithoutParams));
}

// Why do we need watchEffect?
//
// We want to update the imageUrl whenever the user clicks on a field that
// contains an image url. This comes in via props.field, which is literally
// just the eg html span element the user clicks on.
//
// We use this span element to reverse lookup the key:value pair in the
// queryResult array (see comments above those functions). These values
// are then recorded in matchingRecordIndex and matchingFieldPath.
//
// We can't use a computed block because we also want to update imageUrl from
// button navigation within this component. So say we set imageUrl directly via
// props.field, we would need a second mathod to set it via button navigation.
// Currently, when the user clicks a button to move to the next/previous
// picture, it updates the imageUrl based on the matchingRecordIndex and
// matchingFieldPath values - which updateImageUrl knows how to handle.
//
// However, care must be taken. The watchEffect triggers everytime any variable
// that is _read_ within it is written to outside. This is why loadNotes uses
// matchingIndex (this doesn't create a dependency on matchingRecordIndex, and
// hence doesn't trigger watchEffect when matchingRecordIndex changes outside).
// This is also why we DO NOT need 2 separate watchEffects.

watchEffect(() => {
  if (!props.field || !effectiveQueryResult.value) return;

  console.log("ImagePanel: watchEffect triggered");

  // We only update the imageUrl if the user clicks on an image. Even if the
  // query results change, until the user clicks an image, the old image is
  // shown.
  const keyValue = props.field.textContent?.trim().replace(/['"]+/g, '') || '';
  if (isImage(keyValue)) {
    console.log("ImagePanel: image found in the clicked field: ", keyValue);
    const keyElement = props.field.closest('.jv-node')?.querySelector('.jv-key');
    const keyName = keyElement?.textContent?.trim().replace(/[:]+/g, '');

    const { matchingIndex, matchingPath } = constructClickedFieldKeyPath(
      keyName, keyValue);

    if (matchingIndex > -1 && matchingPath) {
      console.log("ImagePanel: matchingIndex: ", matchingIndex, "matchingPath: ", matchingPath);
      matchingRecordIndex.value = matchingIndex;
      matchingFieldPath.value = matchingPath;
      matchingRecord.value = effectiveQueryResult.value[matchingIndex];
      updateImageUrl(effectiveQueryResult.value[matchingIndex], matchingPath);
    } else {
      console.warn("ImagePanel: no matching index/path found for the clicked field.");
    }
  }

  console.log("ImagePanel: effectiveQueryResult: ", effectiveQueryResult.value);

  for (const item of effectiveQueryResult.value.slice(0, 10)) {
    console.log("ImagePanel: item: ", item);
    console.log("ImagePanel: item.notes: ", item.notes);
  }

  // We are fine resetting localQueryResult on every queryResult change
  // because queryResult.value will change only when a different query is run in the
  // schema panel. But we don't want to reset it when the user closes the popup
  // and clicks on another field without changing the query. This is because
  // we don't update the queryResults in the schemaPanel (where the user is
  // clicking) with the notes, we straight update the editorData (i.e the core
  // list from which query result is derived in the schema panel).
  console.log("ImagePanel: queryResultsChanged, resetting localQueryResult");
  localQueryResult.value = effectiveQueryResult.value.map(item => ({
    ...item,
    notes: Array.isArray(item?.notes) ? item.notes : []
  }));
  notes.value = [];
});

/**
 * Shows the previous image or tile.
 */
const showPrevious = () => {
  if (effectiveQueryResult.value.length === 0 || matchingRecordIndex.value === -1) return;

  saveNotes(matchingRecordIndex.value);

  if (isMapWithTiles.value && showPopup.value) {
    // Navigate through tiles within the same object
    const currentRecord = effectiveQueryResult.value[matchingRecordIndex.value];
    const tiles = getValueByPath(currentRecord, tilesPath.value);

    if (Array.isArray(tiles) && tiles.length > 0) {
      currentTileIndex.value = (currentTileIndex.value - 1 + tiles.length) % tiles.length;
      const tileUrl = getTileUrl(currentTileIndex.value);
      if (tileUrl && isImage(tileUrl)) {
        imageUrl.value = tileUrl;
        loadNotes(matchingRecordIndex.value);
        updateTileOverlay(tiles);
        return;
      }
    }
  } else {
    // Normal navigation between objects
    matchingRecordIndex.value = (matchingRecordIndex.value - 1 + effectiveQueryResult.value.length) % effectiveQueryResult.value.length;
    updateImageUrl(
      effectiveQueryResult.value[matchingRecordIndex.value], matchingFieldPath.value);
    loadNotes(matchingRecordIndex.value);
  }
}

/**
 * Shows the next image or tile.
 */
const showNext = () => {
  if (effectiveQueryResult.value.length === 0 || matchingRecordIndex.value === -1) return;

  saveNotes(matchingRecordIndex.value);

  if (isMapWithTiles.value && showPopup.value) {
    // Navigate through tiles within the same object
    const currentRecord = effectiveQueryResult.value[matchingRecordIndex.value];
    const tiles = getValueByPath(currentRecord, tilesPath.value);

    if (Array.isArray(tiles) && tiles.length > 0) {
      currentTileIndex.value = (currentTileIndex.value + 1) % tiles.length;
      const tileUrl = getTileUrl(currentTileIndex.value);
      if (tileUrl && isImage(tileUrl)) {
        imageUrl.value = tileUrl;
        loadNotes(matchingRecordIndex.value);
        updateTileOverlay(tiles);
        return;
      }
    }
  } else {
    // Normal navigation between objects
    matchingRecordIndex.value = (matchingRecordIndex.value + 1) % effectiveQueryResult.value.length;
    updateImageUrl(
      effectiveQueryResult.value[matchingRecordIndex.value], matchingFieldPath.value);
    loadNotes(matchingRecordIndex.value);
  }
}

/**
 * Constructs the key path for the clicked field.
 *
 * If the clicked field is a "value" in the json, this function can find it's
 * key name. It does this by traversing the DOM created by the json-viewer
 * library.
 *
 * When the user directly clicks on a "key", the closest element with a jv-node
 * is that key itself. So we don't find anything matching the value.
 *
 * The way to use this function is to only trigger it based on the imageURL
 * regex, so we're only running it when the user clicks on an image. Otherwise
 * it will end up matching the same key:value in the first field encountered.
 *
 * @params
 *  - props.field: The field that the user clicked on.
 *  - queryResult: The query result array.
 *
 * @returns {Object} An object with the matching index and path. Eg:
 *  { matchingIndex: 0, matchingPath: 'picture.imageURL' }
 *
 * The index is used to continue the traversal of the queryResult array from
 * that image onwards.
 */
function constructClickedFieldKeyPath(keyName, keyValue) {
  if (!keyName || !keyValue) {
    console.log("ImagePanel: no key name/value found for the clicked field.");
    return {
      matchingIndex: -1, matchingPath: ''
    };
  }

  console.log("ImagePanel: finding matching object for key: ", keyName, "value: ", keyValue);
  const { matchingIndex, matchingPath } = findMatchingObject(
    effectiveQueryResult.value,
    keyName,
    keyValue
  );

  return { matchingIndex, matchingPath };
}

/**
 * Finds the matching object in the given array.
 *
 * In order to do this it runs "traverse" on each object of the array, till it
 * encounters the first one that has a matching key:value. This match occurs at
 * the "leaf" level, eg:
 *
 * {
 *   "key1": "value1",
 *   "key2": {
 *     "key3": "value3"
 *   }
 * }
 *
 * The match happens at key3:value3, but the path recorded is key2.key3.
 * This is achieved by recursing on each "object" value encountered, and on
 * each recursion resetting the current path to the current path + the key of
 * that object.
 *
 * @params
 *  - array: The queryResult array.
 *  - keyName: The key name to search for.
 *  - keyValue: The key value to search for.
 *
 * @returns {Object} An object with the matching index and path.
 */
function findMatchingObject(array, keyName, keyValue) {
  if (!array || !keyName || !keyValue) {
    console.warn("ImagePanel: no array, keyName or keyValue found.");
    return {
      matchingIndex: -1, matchingPath: []
    }
  }

  let matchingIndex = -1;
  let matchingPath = '';

  const traverse = (obj, path = []) => {
    if (typeof obj !== 'object' || obj === null) return;

    for (const [key, value] of Object.entries(obj)) {
      const currentPath = [...path, key];
      console.log("ImagePanel currentPath: ", currentPath);

      // Doesn't work for ints/lat/long etc.
      if (key === keyName && value === keyValue) {
        matchingPath = currentPath.join('.');
        return true;
      } else {
        console.log("ImagePanel: key/value not found, found values: ", key, value, " want values: ", keyName, keyValue);
      }

      if (typeof value === 'object') {
        console.log("ImagePanel: traversing object: ", value);
        if (traverse(value, currentPath)) {
          return true;
        }
      }
    }
  }

  for (let i = 0; i < array.length; i++) {
    if (traverse(array[i])) {
      console.log("ImagePanel: found matching index: ", i, "matchingPath: ", matchingPath);
      matchingIndex = i;
      break;
    }
  }

  return { matchingIndex, matchingPath };
}

/**
 * Returns a displayable record data object.
 *
 * Process a whitelist of suffixes to display. Formats those suffixes.
 *
 * @returns {Object} An object with the displayable record data.
 */
const getDisplayableRecordData = () => {
  if (!matchingRecord.value) return [];

  // TODO(prashanth@): "includes" is not a very robust way to match fields.
  const whiteListSuffixes = ['_area'];
  const displayData = [];

    // Add current tile index if in map mode
  if (isMapWithTiles.value) {
    displayData.push({
      key: 'Current Tile',
      value: String(currentTileIndex.value + 1),
      isUrl: false
    })
  }

  for (const [key, value] of Object.entries(matchingRecord.value)) {
    const matchedSuffix = whiteListSuffixes.find(whiteListedSuffix => key.endsWith(whiteListedSuffix));

    if (matchedSuffix) {
      if (matchedSuffix === '_area') {
        displayData.push({
          key: key.replace(matchedSuffix, ''),
          value: String(parseInt(value) / 1000) + 'kmÂ²',
          isUrl: false
        });
      }
    }
  }

  return displayData;
};

function openPopup() {
    showPopup.value = true;

    // If this is a map with tiles, show the first tile instead of the base map
    if (isMapWithTiles.value) {
      const tileUrl = getTileUrl(0);
      if (tileUrl && isImage(tileUrl)) {
        imageUrl.value = tileUrl;
        currentTileIndex.value = 0;

        // Use nextTick to ensure the popup is fully rendered before updating
        // overlay. The problem is @load fires unpredictably, and is triggered
        // by the browser. Sometimes when @load fires, the image is not yet
        // laid out, and sometimes the image is not laid out in time for
        // nextTick.
        // TODO(prashanth@): gh/issue/23
        nextTick(() => {
          const currentRecord = effectiveQueryResult.value[matchingRecordIndex.value];
          const tiles = getValueByPath(currentRecord, tilesPath.value);

          // Check if the preview image is already loaded
          const preview = previewImageRef.value;
          if (preview && preview.complete && preview.naturalWidth > 0) {
            updateTileOverlay(tiles);
          }
        });
      }
    }
    loadNotes(matchingRecordIndex.value);
}

function closePopup() {
    showPopup.value = false;
    console.log("setting showPopup to: ", showPopup.value);
    saveNotes(matchingRecordIndex.value);

    // Reset tile navigation state when closing popup
    if (isMapWithTiles.value) {
      currentTileIndex.value = 0;
    }
}

/**
 * Detects if a value is an Excel serial date and converts it to human-readable format.
 *
 * Excel serial dates are numbers representing days since January 1, 1900.
 * Common Excel serial dates are in the range 1-100000 (roughly 1900-2174).
 *
 * @param {any} value - The value to check and format
 * @returns {string|null} Formatted date string or null if not an Excel serial date
 */
function formatDate(value) {
  // TODO(prashanth@): this should not be in the frontend, or at least, not
  // just in the frontend. The backend should ensure correct date formats.
  if (!value) return null;

  // Convert to number if it's a string
  const numValue = typeof value === 'string' ? parseFloat(value) : value;

  // Check if it's a number and in the Excel serial date range
  if (typeof numValue === 'number' && !isNaN(numValue) && numValue > 0 && numValue < 100000) {
    try {
      // Excel serial dates start from January 1, 1900
      // But Excel incorrectly treats 1900 as a leap year, so we need to adjust
      const excelEpoch = new Date(1900, 0, 1); // January 1, 1900
      const millisecondsPerDay = 24 * 60 * 60 * 1000;

      // Adjust for Excel's leap year bug (it treats 1900 as leap year)
      const adjustedDays = numValue - 2; // Subtract 2 to account for the bug

      const date = new Date(excelEpoch.getTime() + (adjustedDays * millisecondsPerDay));

      // Check if the resulting date is reasonable (not too far in past/future)
      const currentYear = new Date().getFullYear();
      if (date.getFullYear() >= 1900 && date.getFullYear() <= currentYear + 10) {
        return date.toLocaleDateString('en-US', {
          year: 'numeric',
          month: 'short',
          day: 'numeric'
        });
      }
    } catch (error) {
      console.warn('Error converting Excel serial date:', error);
    }
  }

  // If it's not an Excel serial date, return the original value
  return value;
}

/**
 * Updates the tile overlay on the preview image.
 *
 * There are 3 stages to this computation:
 * 1. Calculate the target image dimensions.
 * 2. Calculate the number of rows/cols of tiles in the target image dimensions.
 * 3. Calculate the exact row/col postion of the tile to highlight.
 *
 * A couple of curious things that need understanding before this function is
 * understood:
 * 1. natural width/height is the actual image dimensions, while offset width/
 * height are the dimensions in the DOM (what we view). Eg:
 *   Original: 2000x1500
 *   DOM: 400x300 pixels
 *   object-fit: contain
 *
 * The image is scaled down to fit the container while maintaining the aspect
 * ratio.
 *
 * 2. The image is going to be constrained by the container dimensions. This
 * typically means either it's height is constraint, and the width is scaled
 * appropriately, or viceverse.
 *
 * 3. If the image aspect ratio is greater than the container aspect ratio, the
 * image will be constrained by the container width, and the height will be
 * scaled appropriately.  If the image aspect ratio is less than the container
 * aspect ratio, the image will be constrained by the container height, and the
 * width will be scaled appropriately.
 *
 * 4. Once we have computed the _expected_ number of rows/cols, we can compute
 * the exact row/col position of the tile to highlight by simply taking a
 * modulous of the current tile index by the number of expected rows/cols.
 *
 * 5. Hence the expected rows/cols is key. And this is simply computed by
 * saying hey i have these many tiles in all, and the image is constrained by
 * the container width, so i can compute the number of rows by dividing the
 * total number of tiles by the number of columns.
 *
 * @param {Array} tiles - The tiles to update the overlay for.
 */
function updateTileOverlay(tiles) {
  const preview = previewImageRef.value;
  if (!preview || !Array.isArray(tiles) || tiles.length === 0) {
    return;
  }

  // Get the container dimensions
  const containerWidth = preview.offsetWidth;
  const containerHeight = preview.offsetHeight;

  // Get the natural image dimensions
  const naturalWidth = preview.naturalWidth;
  const naturalHeight = preview.naturalHeight;

  // Calculate the actual displayed image dimensions with object-fit: contain
  const containerAspectRatio = containerWidth / containerHeight;
  const imageAspectRatio = naturalWidth / naturalHeight;

  let imageWidth, imageHeight, imageLeft, imageTop;

  if (imageAspectRatio > containerAspectRatio) {
    // Image is wider than container, fit to width
    imageWidth = containerWidth;
    imageHeight = containerWidth / imageAspectRatio;
    imageLeft = 0;
    imageTop = (containerHeight - imageHeight) / 2;
  } else {
    // Image is taller than container, fit to height
    imageHeight = containerHeight;
    imageWidth = containerHeight * imageAspectRatio;
    imageTop = 0;
    imageLeft = (containerWidth - imageWidth) / 2;
  }

  const total = tiles.length;

  // Calculate optimal grid layout
  // For a square-ish grid, we want cols * rows to be close to total
  // and cols/rows to be close to the aspect ratio
  const aspectRatio = imageWidth / imageHeight;

  // Calculate optimal number of columns based on aspect ratio
  const cols = Math.round(Math.sqrt(total * aspectRatio));
  const rows = Math.ceil(total / cols);

  const index = currentTileIndex.value;
  const col = index % cols;
  const row = Math.floor(index / cols);

  // Calculate tile dimensions based on actual displayed image size
  const tileWidth = imageWidth / cols;
  const tileHeight = imageHeight / rows;

  tileOverlayStyle.value = {
    position: 'absolute',
    border: '2px solid #EFBF02',
    left: `${imageLeft + col * tileWidth}px`,
    top: `${imageTop + row * tileHeight}px`,
    width: `${tileWidth}px`,
    height: `${tileHeight}px`,
    pointerEvents: 'none',
    boxSizing: 'border-box',
  };
}

</script>

<style scoped>
.image-container {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 100%;
    height: 100%;
    overflow: hidden;
    border-radius: 8px;
    cursor: pointer;
}

img {
    max-width: 100%;
    border-radius: 8px;
}

/* Image popup
 *
 * popup-overlay: is the blurry background.
 * popup-card: is the container for both the image and the text.
 * popup-image: is the left half of popup-card, the image.
 * popup-description: is the right half of the popup-card, the text.
 */

.popup-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(10px);
    z-index: 1000;
}

.popup-card {
    display: flex;
    width: 90%;
    height: 90%;
    border-radius: 15px;
    overflow: hidden;
    position: relative;
    box-shadow: 0px 0px 20px rgba(0, 0, 0, 0.5);
}

/*
 * Do NOT use justify-content: center; here because it messes with the
 * coordinates of the notes.
 */
.popup-image-container {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    max-width: 100%;
    height: 100%;
    overflow: hidden;
}

.popup-image {
    object-fit: contain;
    height: auto;
    /* Why not preserve aspect ratio?
     *
     * fill: The image will be distorted. i.e if it's a rectangular image, and
     * the container is square, the rectangle is stretched to fill the square.
     *
     * cover: the image will NOT be distored, but it may be zoomed in/cropped to
     * fill the container.
     *
     * contain: The image will NOT be distorted, if it is larger than the
     *  container, it will be scaled down, if it's smaller, scaled up, but its
     *  aspect ratio won't be changed (i.e a 200x100 image will become a
     *  400x200 image, even in a 400x400 container).
     *
     * And finally object-fit: scale-down will avoid scaling up like contain
     * does, it will only scale down if the image doesn't fit.
     *
     * We want to use fill to make sure the overlay notes position correctly.
     * This is the same reason for width == height == 100%.
     */
    width: 100%;
    height: 100%;
    object-fit: fill;
}


.popup-description {
    flex: 1;
    /* background-color: #0C0D10; */
    color: white;
    padding: 2em;
    display: flex;
    flex-direction: column;
    text-align: left;
    height: 100%;
    box-sizing: border-box;
}

.popup-description-topbar {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    font-weight: bold;
    color: #B0B0B0;
    margin-bottom: 1em;
}

.popup-description-username {
    display: inline-flex;
    align-items: center;
}

.popup-description-content {
    margin-top: 1em;
    font-size: calc(1vw + 0.5em);
    line-height: 1.5em;
    word-wrap: break-word;
    flex-grow: 1;
    overflow-y: auto;
}

.popup-description-content p {
    margin: 0;
    padding: 0;
}

.popup-close {
    position: absolute;
    top: 8px;
    right: 15px;
    z-index: 10;

    font-size: 1.5em;
    color: #B0B0B0;
    cursor: pointer;
    background: none;
    border: none;
    padding: 0;
    transition: color 0.3s ease;
    border-radius: 50%;
    display: flex;
}

.popup-close:hover {
    color: #fff;
}

/* Map Preview Section */

.preview-container {
  position: relative;
  max-width: 50%;
  max-height: 50%;
}

.preview-image {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

.tile-overlay {
  position: absolute;
  border: 2px solid red;
  z-index: 2;
  pointer-events: none;
  box-sizing: border-box;
}

/* AI results section */
.ai-section {
    padding: 1em 0.5em 0.5em 1em;
    border-radius: 8px;
    margin-top: 1em;
    font-size: calc(0.8vw + 0.5em);
    border: 1px solid #333;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);

    word-wrap: break-word;
    overflow-y: auto;
    font-family: "Courier New", Courier, monospace;
    text-align: left;
    font-family: monospace;
}

.ai-results-content {
    padding-left: 10px;
    padding-top: 10px;
}

.ai-results-footer {
    display: flex;
    justify-content: flex-end;
    padding-top: 10px;
}

.ai-results-footer strong {
  font-size: 10px;
  color: #ada579;
  text-align: right;
}

.ai-results-content strong {
  color: #ccc;
}

.ai-results-content div {
  color: #ada579;
}

.editor-switcher {
  position: absolute;
  bottom: 20px;
  display: flex;
  border-radius: 5px;
  overflow: hidden;
  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
  background-color: #151515;
}

.editor-switcher button {
  border: none;
  color: rgb(21, 21, 21, 0.5);
  cursor: pointer;
  position: relative;
  background-color: transparent;
  color: #1E628C;
}

.editor-switcher button:hover:not(:disabled) {
  color: #3388ff;
}

.note {
  position: absolute;
  background: rgb(255, 255, 0);
  color: black;
  font-size: 12px;
  transform: translate(-50%, -50%);
  border-radius: 3px;
}

</style>
